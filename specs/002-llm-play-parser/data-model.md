# Data Model: LLM Play Parser

**Date**: November 30, 2025  
**Phase**: 1 (Design & Contracts)  
**Status**: Complete

## Overview

This document defines the Zod schemas for validating LLM-parsed play data. All schemas mirror the existing TypeScript types from `src/lib/mock-data.ts` while adding runtime validation and business rules.

## ID Management Strategy

**CRITICAL**: The database is the sole source of truth for entity IDs. LLM-generated IDs serve only as temporary references during the parsing process and MUST NOT be persisted as primary identifiers.

### Principles

1. **Database Authority**: All primary IDs (`id` fields) are generated by the database using `@default(uuid())` in Prisma schema
2. **LLM IDs as Supplementary**: LLM-generated IDs are stored separately as `llmSourceId` for reference/debugging purposes only
3. **No Uniqueness Guarantee**: LLM cannot ensure ID uniqueness or database consistency; duplicates are possible
4. **Discard After Mapping**: Once entities are persisted to the database, LLM IDs are only retained for audit/troubleshooting

### Implementation Flow

```
1. LLM generates play structure with temporary IDs → llmSourceId
2. Parser creates mapping table: { llmId → dbId }
3. Database generates canonical UUIDs → id (primary key)
4. All foreign key references use database-generated IDs
5. llmSourceId stored for debugging only (optional field)
```

---

## Entity Definitions

### Playbook

The root entity representing a complete theatrical play.

**TypeScript Type** (existing):

```typescript
type Playbook = {
  id: string;
  title: string;
  author: string;
  year: number;
  genre: string;
  description: string;
  coverImage?: string;
  characters: Character[];
  acts: Act[];
};
```

**Zod Schema** (new):

```typescript
import { z } from "zod";

export const PlaybookSchema = z.object({
  // LLM-generated temporary ID (for internal mapping during parsing)
  llmSourceId: z.string().uuid().optional(),
  // Database will generate the canonical id - not set by LLM
  // id: generated by database @default(uuid())

  title: z.string().min(1, "Title is required"),
  author: z.string().min(1, "Author is required"),
  year: z.number().int().min(1000).max(2100).optional(),
  genre: z.string().optional(),
  description: z.string().optional(),
  coverImage: z.string().url().optional(),
  characters: z
    .array(CharacterSchema)
    .min(1, "At least one character required"),
  acts: z.array(ActSchema).min(1, "At least one act required"),
});

export type PlaybookParsed = z.infer<typeof PlaybookSchema>;
```

**Validation Rules**:

- `llmSourceId`: Optional UUID from LLM for debugging/mapping purposes only
- `id`: **NOT** included in schema - generated by database on insert
- `title`: Required, non-empty string
- `author`: Required, non-empty string
- `year`: Optional, but if provided must be 1000-2100
- `characters`: At least 1 character required
- `acts`: At least 1 act required

**ID Management**:

- LLM may generate `llmSourceId` during parsing for internal reference
- Database generates canonical `id` when entity is persisted
- Parser maintains mapping table: `Map<llmSourceId, dbId>` during import
- `llmSourceId` stored in database as supplementary field for audit trail

---

### Character

Represents a character in the play.

**TypeScript Type** (existing):

```typescript
type Character = {
  id: string;
  name: string;
  description: string;
  isFavorite?: boolean;
  lastSelected?: boolean;
  completionRate?: number;
};
```

**Zod Schema** (new):

```typescript
export const CharacterSchema = z.object({
  // LLM-generated temporary ID (for internal mapping during parsing)
  llmSourceId: z.string().uuid().optional(),
  // Database will generate the canonical id - not set by LLM
  // id: generated by database @default(uuid())

  name: z.string().min(1, "Character name is required"),
  description: z.string().optional(),
  // Practice-related fields not set during parsing
  isFavorite: z.boolean().optional(),
  lastSelected: z.boolean().optional(),
  completionRate: z.number().min(0).max(100).optional(),
});

export type CharacterParsed = z.infer<typeof CharacterSchema>;
```

**Validation Rules**:

- `llmSourceId`: Optional UUID from LLM for debugging/mapping purposes only
- `id`: **NOT** included in schema - generated by database on insert
- `name`: Required, non-empty string (character names like "HAMLET", "ROMEO")
- `description`: Optional character description from dramatis personae
- Practice fields (`isFavorite`, `lastSelected`, `completionRate`) optional, not set by LLM

**LLM Parsing Notes**:

- Extract from "Dramatis Personae" or "Characters" section
- Name should be normalized (e.g., "HAMLET" → "Hamlet")
- LLM may generate `llmSourceId` for cross-referencing during parsing
- Database assigns canonical `id` upon persistence

**ID Management**:

- LLM generates temporary `llmSourceId` to link characters to their lines
- Parser builds mapping: `Map<character.llmSourceId, character.dbId>`
- When persisting lines, use mapping to set correct `characterId` foreign key
- `llmSourceId` retained in DB for debugging duplicate character detection

---

### Act

Represents a major division of the play.

**TypeScript Type** (existing):

```typescript
type Act = {
  id: string;
  title: string;
  scenes: Scene[];
};
```

**Zod Schema** (new):

```typescript
export const ActSchema = z.object({
  // LLM-generated temporary ID (for internal mapping during parsing)
  llmSourceId: z.string().uuid().optional(),
  // Database will generate the canonical id - not set by LLM
  // id: generated by database @default(uuid())

  title: z.string().min(1, "Act title is required"),
  scenes: z.array(SceneSchema).min(1, "At least one scene required per act"),
});

export type ActParsed = z.infer<typeof ActSchema>;
```

**Validation Rules**:

- `llmSourceId`: Optional UUID from LLM for debugging/mapping purposes only
- `id`: **NOT** included in schema - generated by database on insert
- `title`: Required (e.g., "Act 1", "ACT I", "Acte premier")
- `scenes`: At least 1 scene required per act

**LLM Parsing Notes**:

- Detect act boundaries: "ACT I", "ACT ONE", "Act 1", "Acte I"
- Preserve original numbering style in title
- LLM may generate `llmSourceId` for internal tracking
- Database assigns canonical `id` with `@default(uuid())`

---

### Scene

Represents a subdivision within an act.

**TypeScript Type** (existing):

```typescript
type Scene = {
  id: string;
  title: string;
  lines: Line[];
};
```

**Zod Schema** (new):

```typescript
export const SceneSchema = z.object({
  // LLM-generated temporary ID (for internal mapping during parsing)
  llmSourceId: z.string().uuid().optional(),
  // Database will generate the canonical id - not set by LLM
  // id: generated by database @default(uuid())

  title: z.string().min(1, "Scene title is required"),
  lines: z.array(LineSchema).min(1, "At least one line required per scene"),
});

export type SceneParsed = z.infer<typeof SceneSchema>;
```

**Validation Rules**:

- `llmSourceId`: Optional UUID from LLM for debugging/mapping purposes only
- `id`: **NOT** included in schema - generated by database on insert
- `title`: Required (e.g., "Scene 1: A public place", "SCENE I", "Scène 1")
- `lines`: At least 1 line required per scene

**LLM Parsing Notes**:

- Detect scene boundaries: "SCENE 1", "Scene i", "Scène première"
- Include location/setting in title if present
- LLM may generate `llmSourceId` for internal tracking
- Database assigns canonical `id` with `@default(uuid())`

---

### Line

Represents a single line of dialogue or stage direction.

**TypeScript Type** (existing):

```typescript
type Line = {
  id: string;
  characterId?: string; // note: stage directions may not have a characterId
  text: string;
  type: "dialogue" | "stage_direction";
  rehearsalCount?: number;
};
```

**Zod Schema** (new):

```typescript
export const LineSchema = z
  .object({
    // LLM-generated temporary ID (for internal mapping during parsing)
    llmSourceId: z.string().uuid().optional(),
    // Database will generate the canonical id - not set by LLM
    // id: generated by database @default(uuid())

    // Single-speaker attribution (references LLM's llmSourceId during parsing)
    characterLlmId: z.string().uuid().optional(),
    // Multi-speaker attribution (references LLM's llmSourceIds during parsing)
    characterLlmIdArray: z.array(z.string().uuid()).min(1).optional(),

    text: z.string().min(1, "Line text is required"),
    type: z.enum(["dialogue", "stage_direction"]),

    // Practice-related fields not set during parsing
    rehearsalCount: z.number().int().min(0).optional(),
  })
  .refine(
    (line) => {
      // Business rule: dialogue lines MUST have either characterLlmId or characterLlmIdArray
      if (
        line.type === "dialogue" &&
        !line.characterLlmId &&
        !line.characterLlmIdArray
      ) {
        return false;
      }
      return true;
    },
    {
      message:
        "Dialogue lines must have a characterLlmId or characterLlmIdArray",
      path: ["characterLlmId"],
    }
  );

export type LineParsed = z.infer<typeof LineSchema>;
```

**Validation Rules**:

- `llmSourceId`: Optional UUID from LLM for debugging/mapping purposes only
- `id`: **NOT** included in schema - generated by database on insert
- `characterLlmId`:
  - References character's `llmSourceId` during parsing (not database ID)
  - Optional for `stage_direction` type
  - **Required** for `dialogue` type: at least one of `characterLlmId` or `characterLlmIdArray` must be present
  - Use `characterLlmId` for single speaker; use `characterLlmIdArray` for multiple speakers
- `text`: Required, non-empty string
- `type`: Must be either `'dialogue'` or `'stage_direction'`

**ID Management**:

- During parsing: LLM uses `characterLlmId` to reference character's `llmSourceId`
- Before persistence: Parser maps `characterLlmId` → actual database `characterId` using mapping table
- Database stores foreign key `characterId` (or via LineCharacter join table for multi-speaker)
- Original `llmSourceId` retained for debugging line attribution issues

**Multi-Character Support**:

```typescript
// Single character dialogue (during LLM parsing)
{
  llmSourceId: "llm-line-123",
  characterLlmId: "llm-char-hamlet",  // References character's llmSourceId
  type: "dialogue",
  text: "To be or not to be"
}
// After DB persistence: characterLlmId mapped to actual characterId FK

// Multi-character dialogue (both characters speak together)
{
  llmSourceId: "llm-line-456",
  characterLlmIdArray: ["llm-char-rosencrantz", "llm-char-guildenstern"],
  type: "dialogue",
  text: "We agree!"
}
// After DB persistence: LineCharacter join records created with mapped characterIds

// Stage direction (no character)
{
  llmSourceId: "llm-line-789",
  type: "stage_direction",
  text: "Thunder and lightning"
}

// Stage direction (on single character)
{
  llmSourceId: "llm-line-101",
  characterLlmId: "llm-char-hamlet",
  type: "stage_direction",
  text: "Exits stage left"
}

// Stage direction (multiple characters)
{
  llmSourceId: "llm-line-102",
  characterLlmIdArray: ["llm-char-rosencrantz", "llm-char-guildenstern"],
  type: "stage_direction",
  text: "They exit together"
}
```

**LLM Parsing Notes**:

- Detect character speaker prefix: "HAMLET:", "Romeo.", "UN:"
- Multi-character indicators: "BOTH:", "ALL:", "CROWD:", "ENSEMBLE:"
- Stage directions often in:
  - Parentheses: "(Exit)"
  - Italics: "_He draws his sword_"
  - Brackets: "[Thunder]"
  - All caps with no speaker: "THUNDER AND LIGHTNING"
- LLM generates `llmSourceId` for the line
- LLM uses character's `llmSourceId` in `characterLlmId` fields (not database IDs)
- Parser performs mapping: `characterLlmId` → `characterId` before persistence

---

## Schema Composition

### Full Schema Hierarchy

```
PlaybookSchema (LLM parsing phase)
├── llmSourceId: UUID (optional, LLM-generated for mapping)
├── title: string (required)
├── author: string (required)
├── year: number (optional)
├── genre: string (optional)
├── description: string (optional)
├── coverImage: URL (optional)
├── characters: Character[] (min 1)
│   └── CharacterSchema
│       ├── llmSourceId: UUID (optional, LLM-generated for mapping)
│       ├── name: string (required)
│       └── description: string (optional)
└── acts: Act[] (min 1)
    └── ActSchema
        ├── llmSourceId: UUID (optional, LLM-generated for mapping)
        ├── title: string (required)
        └── scenes: Scene[] (min 1)
            └── SceneSchema
                ├── llmSourceId: UUID (optional, LLM-generated for mapping)
                ├── title: string (required)
                └── lines: Line[] (min 1)
                    └── LineSchema
                        ├── llmSourceId: UUID (optional, LLM-generated for mapping)
                        ├── characterLlmId: UUID (optional, refs character.llmSourceId)
                        ├── characterLlmIdArray: UUID[] (optional, refs character.llmSourceId)
                        ├── text: string (required)
                        └── type: "dialogue" | "stage_direction"

Database Schema (after persistence)
├── id: UUID (generated by @default(uuid()))
├── llmSourceId: UUID (optional, stored for debugging)
├── title: string
├── author: string
├── year: number (optional)
├── genre: string (optional)
├── description: string (optional)
├── coverImage: URL (optional)
├── characters: Character[]
│   └── Character
│       ├── id: UUID (generated by @default(uuid()))
│       ├── llmSourceId: UUID (optional, stored for debugging)
│       ├── name: string
│       └── description: string (optional)
└── acts: Act[]
    └── Act
        ├── id: UUID (generated by @default(uuid()))
        ├── llmSourceId: UUID (optional, stored for debugging)
        ├── title: string
        └── scenes: Scene[]
            └── Scene
                ├── id: UUID (generated by @default(uuid()))
                ├── llmSourceId: UUID (optional, stored for debugging)
                ├── title: string
                └── lines: Line[]
                    └── Line
                        ├── id: UUID (generated by @default(uuid()))
                        ├── llmSourceId: UUID (optional, stored for debugging)
                        ├── characters: LineCharacter[] (join table, uses db IDs)
                        ├── text: string
                        └── type: "dialogue" | "stage_direction"
```

**Key Transformation During Persistence**:

1. LLM output validated against parsing schemas (with `llmSourceId` fields)
2. Entities inserted into database (generates canonical `id` via `@default(uuid())`)
3. Mapping table built: `{ characterLlmId → characterDbId }`, etc.
4. Foreign keys (`characterId`, `sceneId`, etc.) set using database-generated IDs
5. Original `llmSourceId` values stored for debugging/audit purposes

---

## Validation Examples

### Valid Playbook (LLM Parsing Output)

```typescript
const validPlay: PlaybookParsed = {
  llmSourceId: "llm-play-hamlet-001", // LLM-generated, for mapping only
  title: "Hamlet",
  author: "William Shakespeare",
  year: 1600,
  genre: "Tragedy",
  description: "The Prince of Denmark seeks revenge",
  characters: [
    {
      llmSourceId: "llm-char-hamlet-001", // LLM-generated, for mapping only
      name: "Hamlet",
      description: "Prince of Denmark",
    },
    {
      llmSourceId: "llm-char-ophelia-001", // LLM-generated, for mapping only
      name: "Ophelia",
      description: "Daughter of Polonius",
    },
  ],
  acts: [
    {
      llmSourceId: "llm-act-1-001",
      title: "Act I",
      scenes: [
        {
          llmSourceId: "llm-scene-1-001",
          title: "Scene 1: Elsinore Castle",
          lines: [
            {
              llmSourceId: "llm-line-001",
              text: "Enter two sentinels",
              type: "stage_direction",
            },
            {
              llmSourceId: "llm-line-002",
              characterLlmId: "llm-char-hamlet-001", // References character's llmSourceId
              text: "To be or not to be, that is the question",
              type: "dialogue",
            },
            {
              llmSourceId: "llm-line-003",
              characterLlmIdArray: [
                // Multi-speaker, references llmSourceIds
                "llm-char-hamlet-001",
                "llm-char-ophelia-001",
              ],
              text: "Good night!",
              type: "dialogue",
            },
          ],
        },
      ],
    },
  ],
};

// Validation
const result = PlaybookSchema.safeParse(validPlay);
if (result.success) {
  console.log("Valid play!", result.data);
  // Next step: persist to database, which will:
  // 1. Generate canonical UUIDs for all entities
  // 2. Map characterLlmId → characterId using DB-generated IDs
  // 3. Store llmSourceId fields for debugging
} else {
  console.error("Validation errors:", result.error.errors);
}
```

### After Database Persistence

```typescript
// After persisting to database, the play looks like:
const persistedPlay = {
  id: "db-uuid-playbook-123", // ← Database-generated via @default(uuid())
  llmSourceId: "llm-play-hamlet-001", // ← Retained for debugging
  title: "Hamlet",
  author: "William Shakespeare",
  // ... other fields ...
  characters: [
    {
      id: "db-uuid-char-456", // ← Database-generated
      llmSourceId: "llm-char-hamlet-001", // ← Retained for debugging
      playbookId: "db-uuid-playbook-123", // ← Foreign key (DB-generated)
      name: "Hamlet",
    },
    {
      id: "db-uuid-char-789", // ← Database-generated
      llmSourceId: "llm-char-ophelia-001", // ← Retained for debugging
      playbookId: "db-uuid-playbook-123", // ← Foreign key (DB-generated)
      name: "Ophelia",
    },
  ],
  acts: [
    {
      id: "db-uuid-act-111", // ← Database-generated
      llmSourceId: "llm-act-1-001",
      playbookId: "db-uuid-playbook-123", // ← Foreign key
      scenes: [
        {
          id: "db-uuid-scene-222", // ← Database-generated
          llmSourceId: "llm-scene-1-001",
          actId: "db-uuid-act-111", // ← Foreign key
          lines: [
            {
              id: "db-uuid-line-333", // ← Database-generated
              llmSourceId: "llm-line-002",
              sceneId: "db-uuid-scene-222", // ← Foreign key
              text: "To be or not to be, that is the question",
              type: "dialogue",
              // characterLlmId was mapped to actual characterId:
              characters: [
                {
                  lineId: "db-uuid-line-333",
                  characterId: "db-uuid-char-456", // ← DB ID, not LLM ID!
                  order: 0,
                },
              ],
            },
            {
              id: "db-uuid-line-444", // ← Database-generated
              llmSourceId: "llm-line-003",
              sceneId: "db-uuid-scene-222",
              text: "Good night!",
              type: "dialogue",
              // characterLlmIdArray was mapped to LineCharacter records:
              characters: [
                {
                  lineId: "db-uuid-line-444",
                  characterId: "db-uuid-char-456", // Hamlet (DB ID)
                  order: 0,
                },
                {
                  lineId: "db-uuid-line-444",
                  characterId: "db-uuid-char-789", // Ophelia (DB ID)
                  order: 1,
                },
              ],
            },
          ],
        },
      ],
    },
  ],
};
```

### Invalid Examples

```typescript
// Missing required field (author)
const invalid1 = {
  llmSourceId: "llm-play-001",
  title: "Hamlet",
  // author missing!
  characters: [],
  acts: [],
};
// Error: "Author is required"

// Dialogue without characterLlmId
const invalid2 = {
  ...validPlay,
  acts: [
    {
      ...validPlay.acts[0],
      scenes: [
        {
          ...validPlay.acts[0].scenes[0],
          lines: [
            {
              llmSourceId: "llm-line-bad",
              text: "To be or not to be",
              type: "dialogue",
              // characterLlmId missing for dialogue!
            },
          ],
        },
      ],
    },
  ],
};
// Error: "Dialogue lines must have a characterLlmId or characterLlmIdArray"

// Empty character array
const invalid3 = {
  ...validPlay,
  characters: [], // Must have at least 1
};
// Error: "At least one character required"

// LLM using wrong ID reference (common mistake)
const invalid4 = {
  ...validPlay,
  acts: [
    {
      ...validPlay.acts[0],
      scenes: [
        {
          ...validPlay.acts[0].scenes[0],
          lines: [
            {
              llmSourceId: "llm-line-005",
              characterLlmId: "db-uuid-char-456", // ❌ Wrong! Should be llmSourceId, not DB ID
              text: "To be or not to be",
              type: "dialogue",
            },
          ],
        },
      ],
    },
  ],
};
// This will pass validation but fail during mapping phase
// Parser will not find "db-uuid-char-456" in the llmSourceId → dbId mapping
```

---

## Usage in LLM Parser

### Multi-Stage Parsing with ID Mapping

```typescript
// src/lib/parse/llm-parser.ts
import { generateObject } from "ai";
import {
  PlaybookSchema,
  CharacterSchema,
  ActSchema,
  LineSchema,
} from "./schemas";

// Stage 1: Extract metadata and characters
const MetadataSchema = z.object({
  title: z.string(),
  author: z.string(),
  year: z.number().optional(),
  genre: z.string().optional(),
  description: z.string().optional(),
  characters: z.array(CharacterSchema),
});

const metadata = await generateObject({
  model,
  schema: MetadataSchema,
  prompt: metadataPrompt,
});

// Build character mapping: llmSourceId → (will be filled with dbId after insert)
const characterMapping = new Map<string, string>();
metadata.object.characters.forEach((char) => {
  if (char.llmSourceId) {
    characterMapping.set(char.llmSourceId, ""); // Placeholder, will be filled after DB insert
  }
});

// Stage 2: Extract act/scene structure
const StructureSchema = z.object({
  acts: z.array(
    z.object({
      llmSourceId: z.string().uuid().optional(),
      title: z.string(),
      scenes: z.array(
        z.object({
          llmSourceId: z.string().uuid().optional(),
          title: z.string(),
          startPosition: z.number(),
          endPosition: z.number(),
        })
      ),
    })
  ),
});

const structure = await generateObject({
  model,
  schema: StructureSchema,
  prompt: structurePrompt,
});

// Stage 3: Extract lines for each scene
const LinesSchema = z.object({
  lines: z.array(LineSchema),
});

const parsedLines = [];
for (const act of structure.object.acts) {
  for (const scene of act.scenes) {
    const sceneText = fullText.slice(scene.startPosition, scene.endPosition);

    const sceneLines = await generateObject({
      model,
      schema: LinesSchema,
      prompt: lineAttributionPrompt(sceneText, metadata.object.characters),
    });

    // Validate each line (uses characterLlmId, not characterId)
    sceneLines.object.lines.forEach((line) => {
      const validation = LineSchema.safeParse(line);
      if (!validation.success) {
        console.error("Line validation failed:", validation.error);
        throw new Error("Invalid line data from LLM");
      }

      // Verify that referenced characterLlmIds exist
      if (line.characterLlmId && !characterMapping.has(line.characterLlmId)) {
        throw new Error(`Unknown character LLM ID: ${line.characterLlmId}`);
      }
      if (line.characterLlmIdArray) {
        line.characterLlmIdArray.forEach((id) => {
          if (!characterMapping.has(id)) {
            throw new Error(`Unknown character LLM ID: ${id}`);
          }
        });
      }
    });

    parsedLines.push(...sceneLines.object.lines);
  }
}

// Stage 4: Persist to database (DB generates canonical IDs)
const prisma = new PrismaClient();

// Insert playbook (DB generates id)
const persistedPlaybook = await prisma.playbook.create({
  data: {
    llmSourceId: metadata.object.llmSourceId, // Optional, for debugging
    title: metadata.object.title,
    author: metadata.object.author,
    year: metadata.object.year,
    genre: metadata.object.genre,
    description: metadata.object.description,
  },
});

// Insert characters and build mapping table
for (const char of metadata.object.characters) {
  const persistedChar = await prisma.character.create({
    data: {
      llmSourceId: char.llmSourceId, // Optional, for debugging
      name: char.name,
      description: char.description,
      playbookId: persistedPlaybook.id, // Use DB-generated ID
    },
  });

  // Update mapping: llmSourceId → dbId
  if (char.llmSourceId) {
    characterMapping.set(char.llmSourceId, persistedChar.id);
  }
}

// Insert acts, scenes, and lines (using mapped character IDs)
for (const act of structure.object.acts) {
  const persistedAct = await prisma.act.create({
    data: {
      llmSourceId: act.llmSourceId,
      title: act.title,
      playbookId: persistedPlaybook.id,
    },
  });

  for (const scene of act.scenes) {
    const persistedScene = await prisma.scene.create({
      data: {
        llmSourceId: scene.llmSourceId,
        title: scene.title,
        actId: persistedAct.id,
      },
    });

    // Filter lines for this scene
    const sceneLinesData = parsedLines.filter(/* belongs to this scene */);

    for (const lineData of sceneLinesData) {
      const persistedLine = await prisma.line.create({
        data: {
          llmSourceId: lineData.llmSourceId,
          text: lineData.text,
          type: lineData.type,
          sceneId: persistedScene.id,
        },
      });

      // Create LineCharacter join records using MAPPED character IDs
      if (lineData.characterLlmId) {
        const dbCharacterId = characterMapping.get(lineData.characterLlmId);
        if (!dbCharacterId) {
          throw new Error(
            `Character mapping not found for ${lineData.characterLlmId}`
          );
        }

        await prisma.lineCharacter.create({
          data: {
            lineId: persistedLine.id, // DB-generated line ID
            characterId: dbCharacterId, // MAPPED from LLM ID to DB ID
            order: 0,
          },
        });
      }

      if (lineData.characterLlmIdArray) {
        for (let i = 0; i < lineData.characterLlmIdArray.length; i++) {
          const llmCharId = lineData.characterLlmIdArray[i];
          const dbCharacterId = characterMapping.get(llmCharId);
          if (!dbCharacterId) {
            throw new Error(`Character mapping not found for ${llmCharId}`);
          }

          await prisma.lineCharacter.create({
            data: {
              lineId: persistedLine.id, // DB-generated line ID
              characterId: dbCharacterId, // MAPPED from LLM ID to DB ID
              order: i,
            },
          });
        }
      }
    }
  }
}

// Final validation: query back from DB and verify structure
const finalValidation = await prisma.playbook.findUnique({
  where: { id: persistedPlaybook.id },
  include: { characters: true, acts: { include: { scenes: true } } },
});

console.log("✅ Playbook persisted with DB-generated IDs");
console.log("Character mapping:", characterMapping);
// Map { 'llm-char-hamlet-001' => 'db-uuid-char-456', 'llm-char-ophelia-001' => 'db-uuid-char-789' }
```

---

## Schema File Structure

### src/lib/parse/schemas.ts

```typescript
import { z } from "zod";

// Character Schema
export const CharacterSchema = z.object({
  llmSourceId: z.string().uuid().optional(),
  name: z.string().min(1, "Character name is required"),
  description: z.string().optional(),
  isFavorite: z.boolean().optional(),
  lastSelected: z.boolean().optional(),
  completionRate: z.number().min(0).max(100).optional(),
});

export type CharacterParsed = z.infer<typeof CharacterSchema>;

// Line Schema with multi-character support
export const LineSchema = z
  .object({
    llmSourceId: z.string().uuid().optional(),
    characterLlmId: z.string().uuid().optional(),
    characterLlmIdArray: z.array(z.string().uuid()).min(1).optional(),
    text: z.string().min(1, "Line text is required"),
    type: z.enum(["dialogue", "stage_direction"]),
    rehearsalCount: z.number().int().min(0).optional(),
  })
  .refine(
    (line) => {
      if (
        line.type === "dialogue" &&
        !line.characterLlmId &&
        !line.characterLlmIdArray
      ) {
        return false;
      }
      return true;
    },
    {
      message:
        "Dialogue lines must have a characterLlmId or characterLlmIdArray",
      path: ["characterLlmId"],
    }
  );

export type LineParsed = z.infer<typeof LineSchema>;

// Scene Schema
export const SceneSchema = z.object({
  llmSourceId: z.string().uuid().optional(),
  title: z.string().min(1, "Scene title is required"),
  lines: z.array(LineSchema).min(1, "At least one line required per scene"),
});

export type SceneParsed = z.infer<typeof SceneSchema>;

// Act Schema
export const ActSchema = z.object({
  llmSourceId: z.string().uuid().optional(),
  title: z.string().min(1, "Act title is required"),
  scenes: z.array(SceneSchema).min(1, "At least one scene required per act"),
});

export type ActParsed = z.infer<typeof ActSchema>;

// Playbook Schema (root)
export const PlaybookSchema = z.object({
  llmSourceId: z.string().uuid().optional(),
  title: z.string().min(1, "Title is required"),
  author: z.string().min(1, "Author is required"),
  year: z.number().int().min(1000).max(2100).optional(),
  genre: z.string().optional(),
  description: z.string().optional(),
  coverImage: z.string().url().optional(),
  characters: z
    .array(CharacterSchema)
    .min(1, "At least one character required"),
  acts: z.array(ActSchema).min(1, "At least one act required"),
});

export type PlaybookParsed = z.infer<typeof PlaybookSchema>;

// Intermediate schemas for multi-stage parsing
export const MetadataSchema = z.object({
  llmSourceId: z.string().uuid().optional(),
  title: z.string().min(1),
  author: z.string().min(1),
  year: z.number().int().min(1000).max(2100).optional(),
  genre: z.string().optional(),
  description: z.string().optional(),
  characters: z.array(CharacterSchema).min(1),
});

export const StructureSchema = z.object({
  acts: z.array(
    z.object({
      llmSourceId: z.string().uuid().optional(),
      title: z.string(),
      scenes: z.array(
        z.object({
          llmSourceId: z.string().uuid().optional(),
          title: z.string(),
          startPosition: z.number().int().min(0),
          endPosition: z.number().int().min(0),
        })
      ),
    })
  ),
});

export const LinesSchema = z.object({
  lines: z.array(LineSchema),
});
```

---

## Next Steps

1. ✅ Schemas defined matching existing types
2. ⏳ Generate API contracts (upload-api.yaml, parse-api.yaml)
3. ⏳ Create quickstart.md with development setup
4. ⏳ Update agent context with Zod + Vercel AI SDK
